---
title: 'let和const命令'
date: '2018-01-15'
spoiler: es6中的声明变量
---
## let命令

### 基本用法

定义：`let`用来声明变量，用法类似于`var`,但是所声明的变量，只在`let`命令所在的代码块内有效。	

语法：

```javascript
{
    let a = 8;
    var b = 6;
}

a // ReferenceError: a is not defined. let声明的变量只在它所在的代码块有效
b // 6
```

`for`循环中使用let

```javascript
for(let i = 0; i < 10; i++) {
    // ...
}
console.log(i)
```

`for`循环中使用`let` ，声明的变量只在块级作用域内有效，变量`i`只在本轮循环中有效。

`for`设置循环变量的部分是一个父作用域，而循环体内部是单独的子作用域，使用`let`可以使`for`循环内部的同名变量拥有各自单独的作用域。

###  不存在变量提升

`var`命令会存在“变量提升”的现象，即变量可以在声明之前使用，值为`undefined`。

`let`所声明的变量一定要在声明后使用，否则报错。

### 暂时性死区

原因：ES6明确规定，如果区块中存在`let`和`const`命令，该区块对声明的变量，会在一开始形成封闭作用域，只要在声明之前使用变量，就会报错。

定义：在代码块内，使用`let`声明变量之前，该变量无法被使用。在语法上称为“暂时性死区”（temporal dead zone，TDZ）

目的：ES6 规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量被声明的代码出现，才可以获取和使用该变量。

“暂时性死区”意味着`typeof`不再是一个百分之百安全的操作。

### 不允许重复声明

`let`不允许在相同作用域内，重复声明同一个变量，会报错。

## 块级作用域

### ES6的块级作用域

Why：ES5只有全局作用域和函数作用域，没有块级作用域，这会带来很多问题。

 	1. 内层变量可能会覆盖外层变量
 	2. 用来计数的循环变量泄露为全局变量 

ES6允许块级作用域任意嵌套，外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量，它的出现使得立即执行函数表达式（IIFE）不再必要。

### 块级作用域与函数声明

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

## const命令

### 基本用法

`const`声明一个只读变量。一旦声明，常量的值就不能改变。

```javascript
const PI = 3.1415
PI // 3.1415
PI = 3 // TypeError: Assignment to constant variable.
```

`const`一旦声明变量就需要立即初始化，给其赋值。

`const`作用域与`let`相同，只在声明所在的块级作用域。

`const`命令声明的变量也不会提升，也存在暂时性死区，不可重复声明。

### 本质

`const`实际上保证的，并不是变量的值不变，而是变量指向的那个内存地址所保存的数据不变。对于基本数据数据类型，值就保存在变量指向的那个内存地址，因此等同于常量。对于引用数据类型，变量指向的内存地址，保存的只是一个指向实际数据的指针。

可使用`Object.freeze`方法将对象冻结。

```javascript
const person = Object.freeze({
    name: 'jason',
    age: 18
})
// 以下代码，常规模式下不起作用，严格模式下报错
person.tel = '186'
```

## 顶层对象的属性

顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。ES5 之中，顶层对象的属性与全局变量是等价的。

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

## global对象

现在有一个[提案](https://github.com/tc39/proposal-global)，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象。

垫片库[`system.global`](https://github.com/ljharb/System.global)模拟了这个提案，可以在所有环境拿到`global`。 

```javascript
// 保证各种环境中，global对象都存在的
import shim from 'system.global/shim'; shim();
// 将顶层对象放入变量global
import getGlobal from 'system.global';
const global = getGlobal();
```

